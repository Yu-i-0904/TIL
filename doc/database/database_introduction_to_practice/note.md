# 書籍名
理論から学ぶデータベース実践入門

# 目的
* 基本的なSQLの書き方を学ぶ
* パフォーマンスが高く、保守しやすいDB設計を学ぶ

# 目次
## 1章 SQLとリレーショナルモデル
## 2章 述語論理とリレーショナルモデル
## 3章 正規化理論（その１）―関数従属性
## 4章 正規化理論（その２）―結合従属性
## 5章 リレーションの直交性
## 6章 ドメインの設計戦略
## 7章 NULLとの戦い
## 8章 SELECTを攻略する
## 9章 履歴データとうまく付き合う
## 10章 グラフに立ち向かう
## 11章 インデックスの設計戦略
## 12章 Webアプリケーションのためのデータ構造
## 13章 リファクタリングの最適解
## 14章 トランザクションの本質

# 1章 SQLとリレーショナルモデル
## 1.1 そもそもSQLって？
* SQLはリレーショナルデータベースに対して問い合わせを行う言語
* リレーショナルモデルをベースにしているが忠実には再現していない
* リレーショナルモデルに沿った使い方も出来れば、大きく逸脱した使い方もできる

## 1.2 リレーショナルモデル
* 現実世界のデータを「リレーション」と呼ばれる概念を用いて表現するデータモデル
* リレーショナルモデルが表すデータモデルは設計という意味ではなく、データをどのように表現するかという概念
* リレーショナルモデルを理解する上で、最も重要な概念が**リレーション**
* SQLにおいてリレーションに相当するものは**テーブル**
* リレーション
  * 見出し（Heading）と本体（Body）で構成される
  * 見出しはn個の属性の集合。属性は名前とデータ型のペアとなっている
  * 本体は属性値の集合である組、あるいはタプル（tuple）の集合。タプルに含まれる属性値は名称とデータ型が見出しで指定したものと一致していること
  * リレーショナルモデルは、集合論に根ざしたデータモデル
* リレーションの演算
  * 制限（Restrict）
    * あるリレーションのうち、特定の条件にあうタプルだけを含んだリレーションを返す
    * 制限を実行した結果は元のリレーションの部分集合と言える
  * 射影（Projection）
    * あるリレーションにおいて、特定の属性だけを含んだリレーションを返す
    * 属性が少なくなると、タプルに重複が生まれ同一のものとして扱われる
  * 拡張（Extend）
    * 射影と反対に属性を増やす操作
    * 多くの場合は新しい属性の値は、既存の属性の鯛を使って算出される
  * 属性名変更（Rename）
    * 属性の名前を変更する
    * 主に拡張した属性に対して名称を与える場合に利用される
  * 和（Union）
    * 2つのリレーションに含まれる、全てのタプルで構成されるリレーション（和集合）を返す
    * 2つのリレーションに共通の属性値が含まれる場合、生成される和集合では重複が解消された状態になる
  * 積/交わり（Intersect）
    * 2つのリレーションの交わり（共通部分）になっているリレーションを返す
  * 差（Difference）
    * 2つのリレーションのうち、片方のリレーションにのみに含まれるタプルで構成されるリレーション
    * どちらのリレーションからどちらのリレーションを引くかで結果が変わる
  * 直積（Product）
    * ある2つのリレーションのタプルをそれぞれ組み合わせたリレーションを返す
    * 生成されたリレーションの見出しには、2つのリレーションの見出しが持つ属性がすべて含まれる
  * 結合（Join）
    * 共通の属性を持つ2つのリレーションをその共通の属性の値が同じタプルを同士を組み合わせたリレーションを返す
    * 結果として残るタプルは、2るのリレーションで共通の属性において、同じ値が存在するものだけ
    * SQLにおいて、内部結合と外部結合にあたる
    * リレーショナルモデルに存在するのは、内部結合のみ
* クロージャ・プロパティ（閉包性）
  * リレーショナルモデルで大切なことは、リレーションを用いた演算結果がリレーションになること
  * 演算の入力も出力も同じデータ構造を持ったものになる性質をクロージャ―（閉包）といい、その性質をクロージャ―・プロパティ（閉包性）という
  * 入出力で同じデータ構造を持つことは重要。演算結果を新たな入力をし、数珠つなぎのように演算を記述することで複雑な演算を表現できる
  * リレーションの演算だけを用いて、複雑な演算を表現できる点がリレーショナルモデルの真骨頂

## 1.3 SQLにおけるリレーション操作
* SELECTの基本形
  * データを参照するために利用できる唯一のコマンド
  * SELECTは論理的には直積、制限、射影の3つリレーションを同時に行う操作と言える（下記は評価の順番）
    * テーブルのリスト（直積）
    * 検索条件（制限）
    * カラムのリスト（射影）
* INSERT（挿入）
  * リレーションをそのリレーションに対して新しくINSERTするタプル（≒行）を追加したリレーションと置き換えるという操作
* DELETE（削除）
  * 元のリレーションを条件と一致しないタプルからなるリレーションに置き換える
* UPDATE（更新）
  * 元のリレーションから条件に一致するタプルからなるリレーションの差集合を取る
  * 上記に対して、差を取ったリレーションに修正を加えたリレーションとの和集合を導く
  * 上記の和集合を代入する
## 1.4 SQLにあってリレーショナルモデルにないもの
* 要素の重複
  * 集合は重複が存在しないが、テーブルは存在する
  * テーブルは多重集合といえ、集合と多重集合では性質が異なる
* 要素間の順序
  * 集合に要素の順序は存在しない
  * SQLには順序が存在する
  * SQLをリレーショナルモデルに沿って使うには、行やカラムの位置を意識したクエリを発行するべきではない
* リレーションの更新
  * リレーションは値であるため更新ができない
  * テーブルが値と変数の両方の機能を兼ねているため更新が可能となっている

# 2章 述語論理とリレーショナルモデル

# 3章 正規化理論（その１）―関数従属性
## 3.2 正規化
* リレーショナルモデルを補完する理論
  * 正規化理論はRDBを使いこなすために必要なテクニックであり、リレーショナルモデルを前提として構築されたDB設計理論
  * リレーショナルモデルの上に立脚し、リレーショナルモデルを補完する理論ともいえる
* 異常を防ぐことができる
  * 最も重要なのは、矛盾を防ぐことができること
  * リレーショナルモデルの異常はを起こす原因は**重複**
  * **重複**があると些細な更新のミスで矛盾が生じる
  * 矛盾が発生しないようにするには**重複**を排除すればよい

## 3.3 正規形
* 正規化にはいくつか段階があり、より高い段階へ進んだ方がより良い状態になる。正規化における各々の段階を正規形（Norml Form）と呼ぶ
* 第1正規形（1NF）
  * 1NFになる条件はリレーションであること
  * これはリレーショナルモデルではなく、SQLに摘要される条件である
  * テーブルが1NFになるため要件とは下記である
    * 行が上から下に順序付けされていない
    * 列が左から右に順序付けされていない
    * 重複する行は存在しない
    * それぞれの行と列の交差点（つまり列の値）は、ドメイン（データ型）に属する要素の値をちょうど1つだけ含んでいる
    * 全ての列の値は定義されたものだけであり、かつそれぞれの行において常に存在する
  * カラムや行の順序
    * SQLの仕様としてテーブル内のカラムに順序が存在するが、カラムや行の位置に依存しないクエリを発行すれば問題にならない
  * 重複する行をなくす
    * 主キーやユニークキーといった一意性を制約をつければ良い（よくある誤解で行が重複していなければそれで正規化はできていると思われる）
    * 行全体がすべて異なる値でもデータに重複が生じることがある
  * NULLが含まれてはいけない
    * NULLが含まれているとリレーショナルモデルが破綻するため、全ての行、カラムには具体的な値が入っていないといけない
    * テーブルを分割し、NULLが入るのを防ぐ
    * アプリケーションは処理の内容に応じて必要なデータを格納するので、カラムの値がNULLであるということはアプリケーションがまだデータを必要としていないということ
  * 値のアトミック性
    * 値はより細かい単位に分割されることなく、全体のアプリケーションにとって意味のあるものでなければ、属性の値としてはいけない
    * ドメインとは属性の取り得る値の集合。集合の要素はそれ以上分解できないからアトミックである
    * つまり、意味のあるデータとは**ドメインの要素の一つである**
  * 繰り返しグループ
    * 典型的な例は、1つの列（ないしは属性）に複数の値をカンマ区切りなどの形式で割り当てるなど
    * 上記のデータ形式では、中の値を分解して演算を行う必要が生じるため、リレーショナルモデルに基づいたロジックを組立られない
    * クエリが複雑になり、データの整合性は危機に瀕し、アプリケーションで実装しなければいけないロジックが膨れ上がる
  * 候補キーとスーパーキー
    * 候補キーとは、そのリレーションに含まれるタプルの値を一意に決められる属性の集合で、なおかつ既約であるものをいう
    * 候補キーは余分な属性を含まない属性の集合であるが、候補キーのスーパーセット（余分な属性を含むもの）をスーパーキーという
    * スーパーキーは一意な値を求めるのに貢献しない属性が含まれているというだけ
    * 候補キーはスーパーキーの一種であり、含まれ属性の数が最小のものである
    * リレーションには重複したタプルが含まれないため、最低でも1つの候補キーが存在する
* 関数従属性（FD）
  * Aの値がわかれば、Bの値が求められる（自明な関数従属性）
  * リレーションの任意の属性は、スーパーキーに関数従属する
  * 2NF～BCNFは自明ではない関数従性を除く作業
* 第2正規形（2NF）
  * 候補キーの真部分集合から非キー属性への関数従属性を取り除く作業
  * 真部分集合とは、部分集合のうちもとの集合自身以外のものを指し、そのような関数従属性を部分関数従属性という
  * リレーションが1NFかつ部分関数従属性が含まれない場合、そのリレーションは2NFとなる
  * 自明ではない関数従属性の正体は、タプル全体として値が重複していなくても、その一部に重複がある状態
  * 重複している値を一度すべて更新するのではなく、一部だけ更新すると異常が発生する
  * 関数従属性を解決するには、1つのリレーションを複数のリレーションに分解する作業を行う
  * 分解後のリレーションに含まれる情報を使って、元のリレーションを再構築できる（無損失分解）
* 第3正規形（3NF）
  * 3NFは推移関数従属性と呼ばれる関数従属性を取り除く作業
  * 推移関数従属性とは、非キー属性間の関数従属性のこと
  * 3NFも2NF同様、無損失分解を行うことで上位の正規形にする
* ボイスコッド正規形（BCNF）
  * 自明でない関数従属性がすべて取り除かれた状態。したがってこれ以上関数従属性による無損失分解はできない
  * 3NFであってBCNFになっていないリレーションは、候補キーになり得る属性の組み合わせが複数存在する
  * 3NFであってもBCNFでない場合は、他に候補キーがないかということを検討する
* まとめ
  * 関数従属性を用いた正規化はいわば、候補キーとなる属性を洗い出す作業
  * そのような隠れた候補キーが見つかった場合は、リレーションを無損失分解することでリレーションの内部から冗長を排除する

# 4章 正規化理論（その２）―結合従属性
## 4.1 結合従属性（JD）
* 結合従属性は、キー自身に冗長性が含まれている場合に生じる重複を指す
* 非キー属性が存在すると、そこにはRK→{非キー属性}という明示的な関数従属性が存在する
* 射影によって候補キーをばらばらにすると、この関数従属性が消失するため無損失分解ができない
* 4NF、5NFになるように正規化する作業は、非キー属性が存在しないリレーションが対象となる
* 4NF、5NFへの正規化は、候補キーに複数の属性が含まれる場合だけ、つまり複合キーである場合だけ必要な作業である
## 4.2 結合従属性による正規化（4NF～6NF）
* 第4正規形（4NF）
  * 一般的に多値従属性（Multi Valued Dependency）による正規化
  * リレーションがBCNFであり、なおかつMVDが排除された状態が4NF
  * 非キー属性を含まないリレーションを結合従属性によって共通の属性を含む、2つのリレーションに無損失分解できるものがMVD
  * 自明ではない結合従属性を解消するのは、射影による無損失分解
* 第5正規形（5NF）
  * 5NFは自明ではない、あるいは暗黙的ではない全ての結合従属性が取り除かれた状態
  * {A, B, C}がある時、{AB, BC, CA}のような結合従属性が取り除かれる
  * 接続の罠
    * 3つ以上のリレーションに分解される結合従属性を**接続の罠**という
    * 分解後の3つのリレーションが、元のリレーションと同じ「事実」を表しているように見えないため
  * 結合従属性は見分けるのが難しいのか？
    * 5NFの対象となる」リレーションは、非キー属性を含まずなおかつ属性が複数ある場合に限られるので、対象を見つけるのは容易
    * 結合従属性を見極める方法として、実際に射影を取ってみて再結合するという方法がある
* 第6正規形（6NF）
  * 6NFは自明な結合従属性（つまり、そのリレーション自身を含む結合従属性）しか存在しないようになるまで、可能な限り全ての結合従属性を排除した状態の正規形
  * 非キー属性の個数が0または1個になるまで、無損失分解された状態が6NF
  * 6NFまで分解したリレーションは無駄な結合が多いため、6NFを目指して正規化することは実用面ではない（5NFでとどめておく）
* まとめ
  * BCNFまで正規化されたリレーションは候補キーが単一の属性で構成されているか、あるいは非キー属性が存在する場合、自動的に5NFの要件まで満たしてる
  * 5NFまで満たしているリレーションは重複がないと言える

# 5章 リレーションの直交性
## 5.1 リレーションの直交性と重複
* リレーションの直交性とは、一言でいうと同じ値を含まないこと
* 直交とは、2つ以上のリレーションに同じ値が含まれないこと
* 同じ見出しを持つリレーションは、意味も近いものになっていると思われるので同じ値が含まれているかもしれない
  * 同じ見出しを持つ2つのリレーションに同じ値があるかどうかは、2つのリレーションを結合してみるとわかる（なければ空集合が返ってくる）
* 見出しの一部だけが同じリレーション
  * 自明でない関数従属性や暗黙的でない結合従属性が存在すると、リレーションを直接比較するだけでは直交しているかわからない
  * 6NFまで分解されたリレーションには自明ではない関数従属性や暗黙的な結合従属性がない
  * リレーションを6NFになるまで部損失分解してから、タプルを比較して重複がないことを確認すれば直交性を保証できる
* リレーションの見出しが同じ場合でも、それらが直交していれば無理に結合する必要はない
* 値が重複しているかどうか、将来的に重複する可能性のある設計かどうかが重要
## 5.2 リレーションの直交性のための戦略
* 正規化
  * 6NFまで正規化をするには5NFまで正規化する必要がある。
  * 正規化はリレーションを扱いしやすくするだけでなく、直交性を確認する際にも役立つ
* 属性（カラム）の名前を統一する
  * 異なるリレーションに現れる属性が同じものを指しているかどうかを識別する必要がある
  * 下記2点を注意すること
    * 命名規則を統一する
    * 主語を含める（name, email, qtyのような汎用的に使われる単語は**何の**あるいは**誰の**プロパティかを示すために主語+単語にする）
* アプリケーションの整合性
  * 2つの異なる機能で同じ意味を持つデータがDBにまたがって登録されている場合、コードのリファクタリングを行う
  * アプリケーションとDBは密なので、リファクタリングを進めることでDBの設計上の問題も解決し、コードの保守性も上がる
* すべてを直交化する必要はない
  * リレーションは集合なので、積集合や和集合に基づいた演算を利用したい場合も出てくる。（それぞれのリレーションが表す条件の意味が完全に独立している）
  * 上記の場合は、重複したデータが互いのリレーションに含まれていても良い
## 5.3 重複を解消することのメリット
* 異常を防ぐことができる
  * DBに含まれる矛盾、すなわちDB内に相反する事実を表す命題が含まれること
  * 前提に矛盾が含まれていると、論理演算によって導き出される（問い合わせ）結果の正しさを保証できない
* 必要なデータがどこにあるのか明確になる
  * 重複を除くとどのリレーション、タプルを参照、更新すれば良いか明確になる
* クエリの記述が宣言的になる
* 不要な無損失分解が必要ない
  * 無損失分解が含まれているとクエリが複雑なうえ、効率的ではない
  * リレーションが正規化されていれば、サブクエリの使用機会が減り、クエリをシンプルに表現することができる
* アプリケーションのコードに無駄がなくなる
  * 異常をチェックする為のロジック、異常が生じた場合のハンドリングについても考える必要があり、ロジックを追加した分テストも行わないとならない

# 6章 ドメインの設計戦略
## 6.1 ドメイン
* リレーショナルモデルにおけるドメインとはデータ型のこと
* つまりドメインとは属性が取り得る値の集合
## 6.2 ドメインの設計戦略の概要
* ドメイン設計は今までの経験であったり、常識、勢いで決めることがほとんどである
* 最終的にはドメインをSQLで表現することになるため、カラムの値が常に何らかの集合（ドメイン）の要素となるようにカラムを設計する必要がある
* SQLのデータ型の定義には表れない設計として、ドメインがカラムのデータ型の背後に存在することになる
* アプリケーションの要求から生まれる
  * アプリケーションにとってどんなデータが必要か認識すること
  * アプリケーションが必要なデータを洗い出す必要がある
  * DB側の設計を行うよりも先に、アプリケーションの設計つまり、どんなデータが入出力されるかどのようなデータを永続化させるか洗い出す必要がある
* DBは本質的なデータを扱うようにする
  * 表示上の問題やユーザーの利便性をDB設計に持ち込んではならない
  * DBが引き受けるのは本質的なデータのみにし、その他はアプリケーション側に任せる
## 6.3 IDを設計するという考え方
* IDを設計する場合はそれが個体に対するものなのか、あるいは集団に対するものなのか、集団であればどの粒度で集団を識別するかといった考慮が必要
* 議題領域が限定されている場合なら、世界全体では一意性を持たないようなラベルでも、IDとして機能することができる
* ナチュラルキー（自然キー）
  * すでにこの世界に存在する何らかの言葉やラベルをキーとして使うというもの
* サロゲートキー（代理キー）
  * この世界には存在せず、DBあるいはそれを利用するアプリケーションの内部だけで通用するID
* どちらを使うべきか
  * 人名のようなナチュラルキーを使用すると重複する恐れがある
  * 現実の世界の物や概念と1:1に対応した集合であれば、ナチュラルキーとして利用してもなんの問題もない
* ナチュラルキーの使いどころと問題点
  * 用いる値がIDとして機能し得るものかどうかが焦点
  * 何かを識別でき、長期に渡り値に変更がなく信頼できると考えられるものはナチュラルキーとして用いて良い
  * IDのライフサイクルを吟味する（システムのライフサイクルより十分に長く運用が継続してくれることが前提）
  * e-mailなどはあくまでe-mailアドレス自身を識別するものなので用いるのは危険（人と1:1の関係にないので人を特定するものではない）
* サロゲートキーの使いどころと問題点
  * 新たにシステムがIDを割り振るのは問題はないが、既にナチュラルキーが存在するにも関わらず、サロゲートキーを新たに作成することは問題
  * 新たにサロゲートキーを作成すると、本来のナチュラルキーにユニーク制約を付ける必要がある（SQLの場合は、ユニークキーを更新するためのオーバーヘッドが生じる）
  * すでに適切なナチュラルキーが存在する場合、本質的にサロゲートキーは不要
* リレーショナルモデルにおけるキー
  * リレーショナルモデルに存在するのは候補キーとスーパーキーのみで、キーという機能は単にタプルに含まれる属性の値を一意に決定できるというものに過ぎない
  * スーパーキーのうち既約の者が候補キーというだけのことで、キーがナチュラルキー、サロゲートキーでも同様にリレーショナルモデルに基づいた設計理論の摘要が可能
  * あくまでドメイン設計の議論であって、リレーショナルモデルの議論ではない
* IDの欠陥は波及する
  * あるリレーションのキーが別のリレーションに登場するため、不適切なIDを選択した場合ありとあらゆるリレーションに悪影響を与える
## 6.4 SQLによるドメインの表現
* 適切なデータ型を選ぶ
  * ドメインそのものとSQLの各種データ型は必ずしも1:1で対応しないが、少なくともドメインの持つであろう値を全てカバーするデータ型を選ぶ必要がある
  * よくある間違いとして、数値型のIDに文字列のカラムを定義すること（無駄にサイズが大きくなる、数値以外が入る、数値として扱えないなどの問題が発生するため）
* 述語を制約で表現する
  * 数値であれば、取り得る数値の範囲を格納できる数値型とCHECK制約で格納されるデータを制限する
  * ドメインとカラムが全単射になることが理想だが、すべてのカラムに制約を付けるのは現実的ではない（手間や制限が増えオーバーヘッドが大きくなる）

# 7章 NULLとの戦い
## 7.1 NULL
* NULLとは
  * カラムの値がわからない時に使うマーカーで、値が存在しない、値が不明ということを示す
  * NULLとなっているカラムの値は、実際には存在しないことになっており、NULLは値ですらない
* 3値論理
  * クエリでテーブルから行を取得する際にNULLによる弊害が顕在化する
  * NULLの演算
    * NULL + 1やNULL > 100の演算の結果はNULLになる
  * NULLによる第3の論理値
    * NULLが含まれているとその時にどう対処するかというロジックを書かないと行けなくなる
    * NULLがあると論理値がTRUE、FALSE、Unknownと3つになり、これらの判定を行うシステムを3値論理という
  * NULLは閉世界仮説に反する
    * リレーショナルモデルは、閉世界仮説という仮説の上に成り立っていて、すべての問いがリレーションの演算だけで解決する
    * NULLはすべての問いがリレーションだけで解決するという閉世界仮説の前提を崩す
    * リレーショナルモデルの元となっている述語論理は2値論理であるため、3値論理を持ち込むと述語論理や集合論理のさまざまな法則が適用できなくなる
## 7.2 ULL対策
* テーブルを正規化する
  * テーブルが1NFの要件を満たすにはNULLが含まれていてはいけない
  * NULLが発生する最大の要因である繰り返しグループを排除する
  * アプリケーションの処理に応じて必要な時に必要なテーブルにデータを格納するため、NULLが入るということはアプリケーションがまだそのデータを必要としていないかもしれない
* 誤ったNULL対策
  * カラムをNOT NULLとして定義し、デフォルト値にNULLと同じような意味を持たせること
* COALESCE関数
  * すべてのカラムにNOT NULLを定義したとしても、NULLが発生する場合がある
    * 行数0の行に対して、SUMやAVGなどの集計関数を実行した場合
    * スカラまたは行サブクエリを実行した結果、該当する行が存在しない場合
    * OUTER JOIN実行時に、マッチする行がなかった場合
    * CASE式において、ELSEを省略している時にどの条件にも該当しなかった場合
    * NULLIF式を評価した結果、NULLになった場合
  * NULLになる可能性のある箇所の特定が出来れば、その後の対策として使えるのがCOALESCE関数である
  * COALESCE関数は式を評価した結果がNULLになる場合のデフォルト値を設定する際に便利
  * どのようなデフォルト値が最適なのかは、式の意味次第である（例としてCOALESCE(SUM(score), 0)のように使う、SUMはテーブルが空や全ての行がNULLの時にNULLとなる）
  * 単にNULLが含まれるカラムに対して、COALESCE関数を使用してデフォルト値を決めるのは避けるべき（デフォルト値にNULLと同じような意味を持たせるのと同じことだから）
* 空文字列の扱い
  * NULLと空文字を同じような意味であるとみなすものがある
  * NULLと空文字は明確に分ける必要がある
* NULLを使っても良いケース
  * SQLは、リレーショナルモデルをベースにしつつ、リレーショナルモデル以外のデータも扱える表現力がある
  * リレーショナルモデルに適合しないデータをテーブルに用いて格納する場合は、リレーショナルモデルの原理原則に従う必要はない
  * その場合はNULLを使用してもよく、正規化をする必要すらない
  * NULLが許容できるかどうか判断するには、対象のデーブルがリレーショナルモデルに沿って設計されたものかどうか明確に理解する必要がある

# 8章 SELECTを攻略する
## 8.1 SELECTはSQLの心臓部
* SELECTの基本構造
  ```
  SELECT カラムのリスト FROM テーブルのリスト WHERE 検索条件
  ```
  * カラムのリストは射影、テーブルのリストは直積、検索条件は制限に相当する操作である
  * RDBは、内部的に様々な最適化を行って結果を算出するため、実行順序が必ずしも論理的な評価の順序と同じになるとは限らない
  * 論理的な評価の順序は、テーブルのリスト → 検索条件 → カラムのリストとなる（実際にどのような順序で評価が実行されるのかという物理的な意味ではない）
## 8.2 SELECT七変化
* 集約関数
  * 構文的に一切同じものがあっても、SELECTにおけるカラムのリストに集約関数があるとSELECTの結果全体が集計結果となる
  * 集約関数の有無だけの違いによって、結果行の意味に大きな変化が生じる（CONCAT()だと結果分行が存在するがCOUNT()にすると1行になる）
  * COUNT()はマッチする行が存在しない場合、0を返却する（他の集約関数は空酒豪に対する評価としてNULLを返却する）
  * GROUP BY句
    * 集約関数はテーブル全体のデータを対象にするが、何か特定の項目ごとの集計を取りたい場合はGROUP BY句を使用する
    * GROUP BY句が用いられていれば、SELECTが集約を表すものだとわかる
    * 厄介な点として、WHERE句の条件に該当するものがなかった場合、その項目については結果が表示されない
  * HAVING句
    * 集計結果についての条件を指定したい場合に使用する
    * WHERE句は集計前の行を指定するため、集計結果の条件指定には使えない
    * SQL標準では、HAVING句を使って条件を指定できるのは、集約関数の結果とGROUP BY句で指定したカラム
  * ORDER BY句
    * 結果をソートしたい時に使用する
  * 評価の順序
    * GROUP BY → HAVING → ORDER BY
  * 相関サブクエリ
    * 該当する行がない項目についても集計を行う際に使用する
    * WHERE句の検索条件にマッチしない行についての集計も必要な場合（GROUP BYが使用できない）に用いる
* サブクエリ
  * テーブルサブクエリ
    * サブクエリの結果がテーブルの体をなしており、3つの種類がある
    * IN, ANY, ALL句に伴って利用されるもの
      * IN句などは、サブクエリの結果が1列だけになる場合が多いが、複数のカラムを一度に比較することも可能
    * FROM句と呼ばれるタイプのもの
      * 集計結果に対してさらに別の集約をする場合などに用いる
  * スカラサブクエリ
    * サブクエリの結果はスカラ（1行1列）でないといけない（そのようにならない結果が返された時はエラーになる）
    * WHERE句やHAVING句などでスカラ値と比較する場合や、カラムのリスト内でスカラを得る時に使用する
  * 行サブクエリ
    * サブクエリを評価した結果が1行で、かつ列が複数ある場合（スカラサブクエリとの違いは、値が複数返ってくるところ）
    * カラムのリスト内では用いることができない（カラムのリスト内は個々の値がスカラである必要があるため）
    * サブクエリの評価結果が複数行ある場合はエラーになるため、確実に1行になる場合のみ使用できる
    * 結果が空の場合はNULLとして扱われるため、真偽値が3VLになる（行サブクエリはCOALESCE()関数が使用できないのでNULLを考慮する必要がある）
* UNION
  * SQLでは、結果セットに含まれるカラム数が同じであれば、2つのSELECTをUNIONで足すことができる
  * 注意する点として、互いに足された2つのSELECTは異なるテーブルを参照していたり、全く異なる実行結果おを持っている
## 8.3 リレーショナルではない操作
* リレーショナルな操作のおさらい
  | リレーションの演算 | SELECTによる表現|
  | ---- | ---- |
  | 制限 | 基本形：WHERE句 |
  | 射影 | 基本形：カラムのリスト |
  | 直積 | 基本形：FROM句 |
  | 結合 | 基本形：FROM句 |
  | 積 | 基本形：FROM句 |
  | 和 | UNION |
  | 差 | NOT EXISTサブクエリ、MINUS |
  | 属性名変更 | 基本形：カラムのリスト |
  | 拡張 | 基本形：カラムのリスト |
  * ほとんどの操作は、SELECTの基本形で対応できる
  * IN, ANY, EXISTSサブクエリは、JOIN（結合）とDISTINCTを用いて書き直せる
  * その他のサブクエリはSELECTによる表現力を飛躍的に高める効果があり、FROM句のサブクエリの集約になっているケースのように、サブクエリは必ずリレーションの演算に対応しているわけではない
* ソート
  * ORDER BY句による結果セットの並べ替えはリレーショナルモデル上の演算ではない
  * リレーショナルモデルは集合理論に基づいたモデルであり、リレーションは集合である
  * そのため、数学的に集合の各要素に順序がない
  * ソートがリレーショナルモデルから外れるからといって、役に立たないものというわけではない（アプリケーション開発においては必須の項目）
  * リレーショナルモデルから逸脱する操作は、危険な要素であり、取扱いに注意する必要があるということ
* ストアドファンクション（ユーザー定義関数）
  * SQLは宣言型のプログラミング言語であるため、手続き型のストアドファンクションを実行するとオプティマイザが実行にかかるコストを予測できず最適化されない
  * 実行のコストが高くなりがち
* リレーショナルではない操作の扱い方
  * SELECTはリレーショナルな操作とそうでない操作の双方を併せ持つ
  * リレーショナルな操作とそうでない操作を明確に区別しておくことが大事
    * リレーショナルモデルの範疇でできることは、決してリレーショナルでない操作で行わない
    * リレーショナルモデルの範疇でうまく記述できないと思ったら、DB設計を見直す
    * リレーショナルではない操作がどうしても必要な場合は、リレーショナルな操作に関するロジックを必ず先に行う
  * リレーショナルな操作で行う、必ず先に行うは重要であり、オプティマイザによる最適化はリレーショナルモデルの範疇で最大の威力を発揮するからである
  * オプティマイザの仕事は、オリジナルのクエリとそっくり同じ結果を得られるクエリの中から最適な実行計画のもの、あるいは最も実行時間が短いと考えられるものを選択すること
  * リレーショナルではない操作が混ざっていると、集合の演算に基づいた書き換えができない
## 8.4 インデントでSELECT文を読みやすくする
* インデントルールを決める
  * SELECT句はインデントしない
  * UNION句はその次のSELECTとまとめて記述する
  * カラムは1行ごとに記述する
  * FROM句のテーブルリスト、WHERE句の検索条件のリストは、1行ずつ記述する。。。など

# 9章 履歴データとうまく付き合う
## 9.1 履歴データの問題点
* 履歴とリレーショナルモデルの相性問題
  * リレーションは集合であるため、データに順序が存在しない
  * だが、履歴にはどちらが新しくどちらが古いという順序が存在する
  * また、テーブルがとても大きくなりやすい
* リレーションと時間軸の直交性
  * 時間によってクエリの実行結果が変わる
  * リレーションとは、ある時点における事実の集合であるため、時間軸と直交していないものはリレーションとは呼べない
* NULLの可能性
  * 最新のもの、現在使用しているものを未来日（2099-12-31）などを設定して判別する場合、それは実質的に期限が設定されていないのと同じである
  * NULLになる場合もあるため、3VLになり検索条件が複雑になる
* 特定の行だけ意味が違う
  * max()関数などで日付の一番新しいものを絞るなどすると、集約はリレーショナルな演算ではないため出力結果がリレーションではなくなる
  * レポーティングではないのに、集約という処理が必要になるのかという点に注意が必要
## 9.2 履歴データに対する解決策
* 絶対的な解はなく、全て次善にすぎないということに注意
* 最もシンプルな分割方法
  * 現在のものと過去のもので2つのリレーションに分割する
  * 現在のものを取得するときのクエリがシンプルになる
  * 過去から現在まで全てのデータを調べる場合は、2つのテーブルを対象とするため、UNIONを使うかクエリを2度発行する必要がある
  * 2つのテーブルの整合性がとれない
    * 同じ行が2つのテーブルに存在する状況はデータの不整合といえる
    * 上記を防ぐには、アプリケーション側で確実に行の移動を1つのトランザクションで実行するようにする
    * または、トリガーを使って、制約を表現する必要がある
  * 外部キーが使用できない
    * 外部キーはあるテーブルに行が含まれることを担保する制約であり、対象のテーブルは1つである必要がある
    * ```list, list_history```のいずれのテーブルに、対応する行が含まれることを担保するという制約を外部キーで表現できない
* 重複した行を許容する
  * 上記の方法では外部キーが使えないため、不便に思うことがある
  * すべてのデータを```list_history```に格納し、最新のもののみを```list```に重複して持つという設計
  * 問題として行が重複しているため、異常の原因になるが問題は限定的なので対策はある
  * 対策
    1. ```list```のデータは、```list_history```に同じ行がないといけないため、外部キー制約を付ける
    2. ```list_history```に先に行をINSERTする
    3. ```list```に同じ行が存在する場合は、古い方を削除する
    4. ```list_history```のデータは基本的にUPDATEしてはいけない、新しい行を追加する
    5. ```list```の行をUPDATEしたい場合は、トリガーを使ってデータを同期する
* サロゲートキー
  * 重複を許容できない場合はサロゲートキー（代理キー）を使った設計を検討する
  * 単一の```list_id_master```テーブルを作成し、外部キー制約を付ける
  * ```list```, ```list_history```それぞれに```list_id_master```と外部キーが必要になる
  * ```list```,テーブルと```list_history```テーブル間では重複してはいけないので、トリガーを使って制約を表現すると良い
  * 問題としては、JOIN（結合）が増えてしまい、操作の回数が多くなってしまう点である
  * また、適切なナチュラルキーがある場合、サロゲートキーは冗長になる
* 未来のデータをどうすべきか
  * 未来の日付が含まれている場合、ある日突然違う値を返すようになる
  * 未来のデータという別の意味があるのであれば、そのデータは別のデータに分けるべき
  * テーブルを分けた場合、そのデータを```list```テーブルに移動する作業が発生する
  * 移動はアプリケーション側でバッチ処理で行うと良い（バッチの実行時間とデータの適応日時に差異が発生する場合もあることに注意）
## 9.3 履歴データのアンチパターン
* フラグを立てる
  * 一部の行が隠れた意味を持つことが問題であり、意味を顕在化させるためにフラグを持たせることは、問題の解決ではなく先送りである
  * カーディナリティが低いため、効率が良くない
  * 本質的な問題は、3NFになっていないという点
  * 日付によって有効なデータをフラグを使って表現する場合、```{start_at, end_at}→{flag}の関係従属性が存在し、フラグは冗長になる
  * また、フラグは自動で更新されないため、アプリケーション側で実装しないといけない

# 10章 グラフに立ち向かう