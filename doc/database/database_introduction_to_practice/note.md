# 書籍名
理論から学ぶデータベース実践入門

# 目的
* 基本的なSQLの書き方を学ぶ
* パフォーマンスが高く、保守しやすいDB設計を学ぶ

# 目次
## 1章 SQLとリレーショナルモデル
## 2章 述語論理とリレーショナルモデル
## 3章 正規化理論（その１）―関数従属性
## 4章 正規化理論（その２）―結合従属性
## 5章 リレーションの直交性
## 6章 ドメインの設計戦略
## 7章 NULLとの戦い
## 8章 SELECTを攻略する
## 9章 履歴データとうまく付き合う
## 10章 グラフに立ち向かう
## 11章 インデックスの設計戦略
## 12章 Webアプリケーションのためのデータ構造
## 13章 リファクタリングの最適解
## 14章 トランザクションの本質

# 1章 SQLとリレーショナルモデル
## 1.1 そもそもSQLって？
* SQLはリレーショナルデータベースに対して問い合わせを行う言語
* リレーショナルモデルをベースにしているが忠実には再現していない
* リレーショナルモデルに沿った使い方も出来れば、大きく逸脱した使い方もできる

## 1.2 リレーショナルモデル
* 現実世界のデータを「リレーション」と呼ばれる概念を用いて表現するデータモデル
* リレーショナルモデルが表すデータモデルは設計という意味ではなく、データをどのように表現するかという概念
* リレーショナルモデルを理解する上で、最も重要な概念が**リレーション**
* SQLにおいてリレーションに相当するものは**テーブル**
* リレーション
  * 見出し（Heading）と本体（Body）で構成される
  * 見出しはn個の属性の集合。属性は名前とデータ型のペアとなっている
  * 本体は属性値の集合である組、あるいはタプル（tuple）の集合。タプルに含まれる属性値は名称とデータ型が見出しで指定したものと一致していること
  * リレーショナルモデルは、集合論に根ざしたデータモデル
* リレーションの演算
  * 制限（Restrict）
    * あるリレーションのうち、特定の条件にあうタプルだけを含んだリレーションを返す
    * 制限を実行した結果は元のリレーションの部分集合と言える
  * 射影（Projection）
    * あるリレーションにおいて、特定の属性だけを含んだリレーションを返す
    * 属性が少なくなると、タプルに重複が生まれ同一のものとして扱われる
  * 拡張（Extend）
    * 射影と反対に属性を増やす操作
    * 多くの場合は新しい属性の値は、既存の属性の鯛を使って算出される
  * 属性名変更（Rename）
    * 属性の名前を変更する
    * 主に拡張した属性に対して名称を与える場合に利用される
  * 和（Union）
    * 2つのリレーションに含まれる、全てのタプルで構成されるリレーション（和集合）を返す
    * 2つのリレーションに共通の属性値が含まれる場合、生成される和集合では重複が解消された状態になる
  * 積/交わり（Intersect）
    * 2つのリレーションの交わり（共通部分）になっているリレーションを返す
  * 差（Difference）
    * 2つのリレーションのうち、片方のリレーションにのみに含まれるタプルで構成されるリレーション
    * どちらのリレーションからどちらのリレーションを引くかで結果が変わる
  * 直積（Product）
    * ある2つのリレーションのタプルをそれぞれ組み合わせたリレーションを返す
    * 生成されたリレーションの見出しには、2つのリレーションの見出しが持つ属性がすべて含まれる
  * 結合（Join）
    * 共通の属性を持つ2つのリレーションをその共通の属性の値が同じタプルを同士を組み合わせたリレーションを返す
    * 結果として残るタプルは、2るのリレーションで共通の属性において、同じ値が存在するものだけ
    * SQLにおいて、内部結合と外部結合にあたる
    * リレーショナルモデルに存在するのは、内部結合のみ
* クロージャ・プロパティ（閉包性）
  * リレーショナルモデルで大切なことは、リレーションを用いた演算結果がリレーションになること
  * 演算の入力も出力も同じデータ構造を持ったものになる性質をクロージャ―（閉包）といい、その性質をクロージャ―・プロパティ（閉包性）という
  * 入出力で同じデータ構造を持つことは重要。演算結果を新たな入力をし、数珠つなぎのように演算を記述することで複雑な演算を表現できる
  * リレーションの演算だけを用いて、複雑な演算を表現できる点がリレーショナルモデルの真骨頂

## 1.3 SQLにおけるリレーション操作
* SELECTの基本形
  * データを参照するために利用できる唯一のコマンド
  * SELECTは論理的には直積、制限、射影の3つリレーションを同時に行う操作と言える（下記は評価の順番）
    * テーブルのリスト（直積）
    * 検索条件（制限）
    * カラムのリスト（射影）
* INSERT（挿入）
  * リレーションをそのリレーションに対して新しくINSERTするタプル（≒行）を追加したリレーションと置き換えるという操作
* DELETE（削除）
  * 元のリレーションを条件と一致しないタプルからなるリレーションに置き換える
* UPDATE（更新）
  * 元のリレーションから条件に一致するタプルからなるリレーションの差集合を取る
  * 上記に対して、差を取ったリレーションに修正を加えたリレーションとの和集合を導く
  * 上記の和集合を代入する
## 1.4 SQLにあってリレーショナルモデルにないもの
* 要素の重複
  * 集合は重複が存在しないが、テーブルは存在する
  * テーブルは多重集合といえ、集合と多重集合では性質が異なる
* 要素間の順序
  * 集合に要素の順序は存在しない
  * SQLには順序が存在する
  * SQLをリレーショナルモデルに沿って使うには、行やカラムの位置を意識したクエリを発行するべきではない
* リレーションの更新
  * リレーションは値であるため更新ができない
  * テーブルが値と変数の両方の機能を兼ねているため更新が可能となっている

# 2章 述語論理とリレーショナルモデル

# 3章 正規化理論（その１）―関数従属性
## 3.2 正規化
* リレーショナルモデルを補完する理論
  * 正規化理論はRDBを使いこなすために必要なテクニックであり、リレーショナルモデルを前提として構築されたDB設計理論
  * リレーショナルモデルの上に立脚し、リレーショナルモデルを補完する理論ともいえる
* 異常を防ぐことができる
  * 最も重要なのは、矛盾を防ぐことができること
  * リレーショナルモデルの異常はを起こす原因は**重複**
  * **重複**があると些細な更新のミスで矛盾が生じる
  * 矛盾が発生しないようにするには**重複**を排除すればよい

## 3.3 正規形
* 正規化にはいくつか段階があり、より高い段階へ進んだ方がより良い状態になる。正規化における各々の段階を正規形（Norml Form）と呼ぶ
* 第1正規形（1NF）
  * 1NFになる条件はリレーションであること
  * これはリレーショナルモデルではなく、SQLに摘要される条件である
  * テーブルが1NFになるため要件とは下記である
    * 行が上から下に順序付けされていない
    * 列が左から右に順序付けされていない
    * 重複する行は存在しない
    * それぞれの行と列の交差点（つまり列の値）は、ドメイン（データ型）に属する要素の値をちょうど1つだけ含んでいる
    * 全ての列の値は定義されたものだけであり、かつそれぞれの行において常に存在する
  * カラムや行の順序
    * SQLの仕様としてテーブル内のカラムに順序が存在するが、カラムや行の位置に依存しないクエリを発行すれば問題にならない
  * 重複する行をなくす
    * 主キーやユニークキーといった一意性を制約をつければ良い（よくある誤解で行が重複していなければそれで正規化はできていると思われる）
    * 行全体がすべて異なる値でもデータに重複が生じることがある
  * NULLが含まれてはいけない
    * NULLが含まれているとリレーショナルモデルが破綻するため、全ての行、カラムには具体的な値が入っていないといけない
    * テーブルを分割し、NULLが入るのを防ぐ
    * アプリケーションは処理の内容に応じて必要なデータを格納するので、カラムの値がNULLであるということはアプリケーションがまだデータを必要としていないということ
  * 値のアトミック性
    * 値はより細かい単位に分割されることなく、全体のアプリケーションにとって意味のあるものでなければ、属性の値としてはいけない
    * ドメインとは属性の取り得る値の集合。集合の要素はそれ以上分解できないからアトミックである
    * つまり、意味のあるデータとは**ドメインの要素の一つである**
  * 繰り返しグループ
    * 典型的な例は、1つの列（ないしは属性）に複数の値をカンマ区切りなどの形式で割り当てるなど
    * 上記のデータ形式では、中の値を分解して演算を行う必要が生じるため、リレーショナルモデルに基づいたロジックを組立られない
    * クエリが複雑になり、データの整合性は危機に瀕し、アプリケーションで実装しなければいけないロジックが膨れ上がる
  * 候補キーとスーパーキー
    * 候補キーとは、そのリレーションに含まれるタプルの値を一意に決められる属性の集合で、なおかつ既約であるものをいう
    * 候補キーは余分な属性を含まない属性の集合であるが、候補キーのスーパーセット（余分な属性を含むもの）をスーパーキーという
    * スーパーキーは一意な値を求めるのに貢献しない属性が含まれているというだけ
    * 候補キーはスーパーキーの一種であり、含まれ属性の数が最小のものである
    * リレーションには重複したタプルが含まれないため、最低でも1つの候補キーが存在する
* 関数従属性（FD）
  * Aの値がわかれば、Bの値が求められる（自明な関数従属性）
  * リレーションの任意の属性は、スーパーキーに関数従属する
  * 2NF～BCNFは自明ではない関数従性を除く作業
* 第2正規形（2NF）
  * 候補キーの真部分集合から非キー属性への関数従属性を取り除く作業
  * 真部分集合とは、部分集合のうちもとの集合自身以外のものを指し、そのような関数従属性を部分関数従属性という
  * リレーションが1NFかつ部分関数従属性が含まれない場合、そのリレーションは2NFとなる
  * 自明ではない関数従属性の正体は、タプル全体として値が重複していなくても、その一部に重複がある状態
  * 重複している値を一度すべて更新するのではなく、一部だけ更新すると異常が発生する
  * 関数従属性を解決するには、1つのリレーションを複数のリレーションに分解する作業を行う
  * 分解後のリレーションに含まれる情報を使って、元のリレーションを再構築できる（無損失分解）
* 第3正規形（3NF）
  * 3NFは推移関数従属性と呼ばれる関数従属性を取り除く作業
  * 推移関数従属性とは、非キー属性間の関数従属性のこと
  * 3NFも2NF同様、無損失分解を行うことで上位の正規形にする
* ボイスコッド正規形（BCNF）
  * 自明でない関数従属性がすべて取り除かれた状態。したがってこれ以上関数従属性による無損失分解はできない
  * 3NFであってBCNFになっていないリレーションは、候補キーになり得る属性の組み合わせが複数存在する
  * 3NFであってもBCNFでない場合は、他に候補キーがないかということを検討する
* まとめ
  * 関数従属性を用いた正規化はいわば、候補キーとなる属性を洗い出す作業
  * そのような隠れた候補キーが見つかった場合は、リレーションを無損失分解することでリレーションの内部から冗長を排除する

# 4章 正規化理論（その２）―結合従属性
## 4.1 結合従属性（JD）
* 結合従属性は、キー自身に冗長性が含まれている場合に生じる重複を指す
* 非キー属性が存在すると、そこにはRK→{非キー属性}という明示的な関数従属性が存在する
* 射影によって候補キーをばらばらにすると、この関数従属性が消失するため無損失分解ができない
* 4NF、5NFになるように正規化する作業は、非キー属性が存在しないリレーションが対象となる
* 4NF、5NFへの正規化は、候補キーに複数の属性が含まれる場合だけ、つまり複合キーである場合だけ必要な作業である
## 4.2 結合従属性による正規化（4NF～6NF）
* 第4正規形（4NF）
  * 一般的に多値従属性（Multi Valued Dependency）による正規化
  * リレーションがBCNFであり、なおかつMVDが排除された状態が4NF
  * 非キー属性を含まないリレーションを結合従属性によって共通の属性を含む、2つのリレーションに無損失分解できるものがMVD
  * 自明ではない結合従属性を解消するのは、射影による無損失分解
* 第5正規形（5NF）
  * 5NFは自明ではない、あるいは暗黙的ではない全ての結合従属性が取り除かれた状態
  * {A, B, C}がある時、{AB, BC, CA}のような結合従属性が取り除かれる
  * 接続の罠
    * 3つ以上のリレーションに分解される結合従属性を**接続の罠**という
    * 分解後の3つのリレーションが、元のリレーションと同じ「事実」を表しているように見えないため
  * 結合従属性は見分けるのが難しいのか？
    * 5NFの対象となる」リレーションは、非キー属性を含まずなおかつ属性が複数ある場合に限られるので、対象を見つけるのは容易
    * 結合従属性を見極める方法として、実際に射影を取ってみて再結合するという方法がある
* 第6正規形（6NF）
  * 6NFは自明な結合従属性（つまり、そのリレーション自身を含む結合従属性）しか存在しないようになるまで、可能な限り全ての結合従属性を排除した状態の正規形
  * 非キー属性の個数が0または1個になるまで、無損失分解された状態が6NF
  * 6NFまで分解したリレーションは無駄な結合が多いため、6NFを目指して正規化することは実用面ではない（5NFでとどめておく）
* まとめ
  * BCNFまで正規化されたリレーションは候補キーが単一の属性で構成されているか、あるいは非キー属性が存在する場合、自動的に5NFの要件まで満たしてる
  * 5NFまで満たしているリレーションは重複がないと言える

# 5章 リレーションの直交性
## 5.1 リレーションの直交性と重複
* リレーションの直交性とは、一言でいうと同じ値を含まないこと
* 直交とは、2つ以上のリレーションに同じ値が含まれないこと
* 同じ見出しを持つリレーションは、意味も近いものになっていると思われるので同じ値が含まれているかもしれない
  * 同じ見出しを持つ2つのリレーションに同じ値があるかどうかは、2つのリレーションを結合してみるとわかる（なければ空集合が返ってくる）
* 見出しの一部だけが同じリレーション
  * 自明でない関数従属性や暗黙的でない結合従属性が存在すると、リレーションを直接比較するだけでは直交しているかわからない
  * 6NFまで分解されたリレーションには自明ではない関数従属性や暗黙的な結合従属性がない
  * リレーションを6NFになるまで部損失分解してから、タプルを比較して重複がないことを確認すれば直交性を保証できる
* リレーションの見出しが同じ場合でも、それらが直交していれば無理に結合する必要はない
* 値が重複しているかどうか、将来的に重複する可能性のある設計かどうかが重要
## 5.2 リレーションの直交性のための戦略
* 正規化
  * 6NFまで正規化をするには5NFまで正規化する必要がある。
  * 正規化はリレーションを扱いしやすくするだけでなく、直交性を確認する際にも役立つ
* 属性（カラム）の名前を統一する
  * 異なるリレーションに現れる属性が同じものを指しているかどうかを識別する必要がある
  * 下記2点を注意すること
    * 命名規則を統一する
    * 主語を含める（name, email, qtyのような汎用的に使われる単語は**何の**あるいは**誰の**プロパティかを示すために主語+単語にする）
* アプリケーションの整合性
  * 2つの異なる機能で同じ意味を持つデータがDBにまたがって登録されている場合、コードのリファクタリングを行う
  * アプリケーションとDBは密なので、リファクタリングを進めることでDBの設計上の問題も解決し、コードの保守性も上がる
* すべてを直交化する必要はない
  * リレーションは集合なので、積集合や和集合に基づいた演算を利用したい場合も出てくる。（それぞれのリレーションが表す条件の意味が完全に独立している）
  * 上記の場合は、重複したデータが互いのリレーションに含まれていても良い
## 5.3 重複を解消することのメリット
* 異常を防ぐことができる
  * DBに含まれる矛盾、すなわちDB内に相反する事実を表す命題が含まれること
  * 前提に矛盾が含まれていると、論理演算によって導き出される（問い合わせ）結果の正しさを保証できない
* 必要なデータがどこにあるのか明確になる
  * 重複を除くとどのリレーション、タプルを参照、更新すれば良いか明確になる
* クエリの記述が宣言的になる
* 不要な無損失分解が必要ない
  * 無損失分解が含まれているとクエリが複雑なうえ、効率的ではない
  * リレーションが正規化されていれば、サブクエリの使用機会が減り、クエリをシンプルに表現することができる
* アプリケーションのコードに無駄がなくなる
  * 異常をチェックする為のロジック、異常が生じた場合のハンドリングについても考える必要があり、ロジックを追加した分テストも行わないとならない