# 書籍名
パーフェクトRuby on Rails

# 目的
* Rails開発の一連の流れの把握とと基礎知識の習得

# 目次
## 1章　Ruby on Railsの概要
* 1-1　Railsを使う前に
* 1-2　Railsの思想
* 1-3　Railsをはじめよう!!
* 1-4　scaffoldを使ってRailsでの開発を体験しよう

## 2章　Ruby on RailsとMVC
* 2-1　MVCアーキテクチャ
* 2-2　モデルを扱う
* 2-3　コントローラの役割
* 2-4　コントローラとビューの協調とビューテンプレートの基本
* 2-5　ビューテンプレートについて

## 3章　押さえておきたいRailsの基本機能
* 3-1　テストの種類と実行方法
* 3-2　RackとRailsの関係
* 3-3　DBを管理する
* 3-4　秘密情報を管理する
* 3-5　HTTPとRailsアプリケーション

## 4章　フロントエンドの開発手法
* 4-1　Webpackerを使ってJavaScriptを管理する
* 4-2　SprocketsによるCSSの管理
* 4-3　Railsに組み込まれているJavaScriptの機能
* 4-4　控えめなJavaScriptフレームワークStimulus

## 5章　Rails標準の機能を活用して素早く機能実装する
* 5-1　Active Jobによる非同期実行
* 5-2　Active Storageによるファイルアップロード
* 5-3　Action Mailerによるメール送信
* 5-4　Action Mailboxによるメール受信
* 5-5　Action Textによるリッチテキスト機能
* 5-6　Action Cableによるリアルタイム通信

## 6章　Railsアプリケーション開発
* 6-1　イベント告知アプリケーションを作る
* 6-2　アプリケーションの作成と下準備
* 6-3　OAuthを利用して「GitHubでログイン」機能を作る
* 6-4　イベントの登録機能を作る
* 6-5　イベントの閲覧機能を作る
* 6-6　イベントの編集・削除機能を作る
* 6-7　登録されたイベントへの参加機能，参加キャンセル機能を作る
* 6-8　退会機能を作る
* 6-9　おわりに

## 7章　Railsアプリケーションのテスト
* 7-1　テストコードをどう書いていくか
* 7-2　minitestとRSpec
* 7-3　テストデータを作成する
* 7-4　システムテスト
* 7-5　コントローラに対する機能テスト
* 7-6　モデルに対するテスト

## 8章　Railsアプリケーション拡張
* 8-1　ファイルアップロード機能を作る
* 8-2　gemで機能拡張をする
* 8-3　落穂ひろい

## 9章　コード品質を上げる
* 9-1　CI（継続的インテグレーション）
* 9-2　Gemの定期update
* 9-3　静的解析
* 9-4　カバレッジ測定
* 9-5　アプリケーションパフォーマンス測定（APM）

## 10章　コンテナを利用したRailsアプリケーションの運用
* 10-1　Railsアプリケーションのインフラ概要
* 10-2　基本的なDockerイメージの構築
* 10-3　開発環境におけるDockerの活用
* 10-4　環境によって可変する設定値や秘匿情報の管理
* 10-5　ログ出力
* 10-6　HTTPサーバとの通信

## 11章　複雑なドメインを表現する
* 11-1　アーキテクチャパターンから見るRails
* 11-2　値オブジェクト
* 11-3　サービスオブジェクト

## 12章　複雑なユースケースを実現する
* 12-1　ユースケースとモデル
* 12-2　データベースと紐づかないモデルを作る
* 12-3　フォームオブジェクト
* 12-4　プレゼンター

## 13章　複雑なデータ操作を実装する
* 13-1　Concern
* 13-2　コールバックオブジェクト

# 1章　Ruby on Railsの概要
# 2章　Ruby on RailsとMVC
# 3章　押さえておきたいRailsの基本機能
# 4章　フロントエンドの開発手法
# 5章　Rails標準の機能を活用して素早く機能実装する
## 5-1　Active Jobによる非同期実行
* Active Jobを利用することでバックエンド上で実行する非同期処理を統一的に利用できる
* ジョブクラス内の`perform`メソッドにジョブで実行したい処理を記述する
* アダプターはデフォルトでasyncが設定されている（プロセスを再起動するとキューの中のジョブは失われるため、本番利用は避ける）
* `perform_later`メソッドはバックエンドキューにジョブを追加して非同期実行する
* 引数として下記を渡すことができる
  * 基本型
  * シンボル
  * 日時を扱う方
  * ハッシュ
  * 配列
  * Active Recordオブジェクト
* 本番環境のアダプターはSidekiq、Resque、Delayed Jobなどが用意されている
* 複数のキューを管理する際は、`queue_as`メソッドを使用することでキューを指定できる
* キューを指定する他の方法で、`set`メソッドを使いqueue引数へキュー名を渡すこともできる
* ジョブのリトライのための`retry_on`と破棄するための`discard_on`が用意されている
  * `attempts`オプションはリトライ回数を指定できる
  * `discard_on`はオプションはなく、キャッチしたい例外クラス（複数可）を指定できる
  * 両メソッドとも引数にブロックを渡すことができるので、ブロック内で処理を書くことができる

## 5-3　Action Mailerによるメール送信
* メイラー、ビュー、設定を規則に沿って実装することができる
* ApplicationMailerを継承し、実装する
* `UserMailer.with(to:, name:).定義したメソッド.deliver_now`で呼び出す
* `with`メソッドの引数で渡した値は、呼び出し先で`params`として使用できる
* @nameなどインスタンス変数としてcontroller同様、ビューに値を渡すことができる
* `mail`メソッドを呼び出すとHTMLとテキストの2種類のテンプレートを探し、multipart/alternative形式のメールを作成する
* `deliver_now`は同期的にメールを送信するメソッド
* `deliver_later`は非同期でメールを送信するメソッド
  * `deliver_later`はActive Jobを使用しているので、キューの永続化など注意が必要
* Action MailerのテストはActionMailer::TestCaseクラスを継承し作成する

# 6章　Railsアプリケーション開発
## 6-7　登録されたイベントへの参加機能，参加キャンセル機能を作る
* どんな時にヘルパーを使うか
  * viewにビジネスロジックを書くと読みづらくなる時
  * グローバル関数のように振る舞うため、数が多くなってくると見通しが悪くなる
  * またヘルパーメソッドの書き方がオブジェクト指向的でない
  * 解決策としてDraperやActiveDecoratorなどのプレゼンター用のgemを利用し、モデルと紐づいた形でview用のロジックを書く
* N+1問題の察知
  * bulletというgemを使うことで、自動でN+1を検知してログ出力やJavaScriptのアラートを出してくれる

# 7章　Railsアプリケーションのテスト
## 7-1　テストコードをどう書いていくか
* TDD（テスト駆動開発）
  * テストを最初に書く（どのような設計にするか）
  * テストを書いた後は、どうやったらテストをパスするかを考え実装する
  * テストをパスするようになったら、どう修正したら綺麗なコードになるか考えリファクタリングする
  * それぞれの段階で、設計、実装、リファクタリングをするだけで良いので、考えることを減らせる
* ブラウザから操作するアプリケーションの場合、E2Eテスト（システムテスト）から書き始めるのが良い
  * 外から見たアプリケーションの動作がわかればテストを書けるので、概要を掴んだ段階でテストを書ける
  * routes、コントローラー、モデル、ビューの全てを通るので、テストカバレッジを広げることができる
  * テストを書いてアプリケーションの使用を確かめることができるので、理解が深まる

## 7-2　minitestとRSpec
* minitest
  * Railsはデフォルトでminitestを利用するようになっている
  * XUnit風とRSpec風の2つの書き方をサポートしている
  * Active Job、Actionn Mailerなどの各機能のテストをするのに便利なヘルパーなど提供されている
* RSpec
  * Railsアプリ開発に利用するテストフレームワークのデフォルトスタンダードといえるライブラリ

# 8章　Railsアプリケーション拡張
## 8-1　ファイルアップロード機能を作る
* Active Storageの下準備
  * bin/rails active_storage:installコマンド実行
  * config/storage.ymlとconfig.active_storage.serviceの設定で保存先を変えられる
* formの作成
  * 既に保存済みの画像があるかどうかはattached?メソッドで確認できる
* 関連したモデルが削除された時の制御
  * モデルのhas_one_attachedのオプションでdependent: falseをつけると関連するActiveStorage::Attachementのみが削除される
* バリデーション
  * Active Storageにはバリデーション用のメソッドがないので、gemを利用する
  * Active Storage Validations gemを利用すると、Active RecordのカラムにバリデーションをかけるようにActive Storage経由でアップロードされたファイルにバリデーションをかけることができる

## 8-2　gemで機能拡張をする
* Kaminari gemでページネーションを機能を作る
  * Kaminariを入れるとpageとperメソッドが使えるようになる
  * pageメソッドには現在のページ数を渡す
  * perメソッドには何件で分割するかを渡す（デフォルトは25件）
  * ビューで`paginate @event`とすることでページネーション用のリンクが生成される

##  8-3　落穂ひろい
* rescue_fromを使用したエラーハンドリング
  * rescue_fromを使用して、特定の例外クラスが発生したときに処理を実行することができる
  * `rescue_from ActiveRecord::RecordNotFound, with: :error_404`のように記述する
  * `rescue_from Exception`が下にあると全てのエラーがマッチしてしまうので注意する
  * ルーティングに設定されていないURLがリクエストされた場合のエラーはrescue_fromでキャッチできない
## 9章　コード品質を上げる
## 9-1　CI（継続的インテグレーション）
* GitHub Actions
  * GitHub上にあるリポジトリでの変更を検知して自動でテストを実行してくれるWebサービス

## 9-2　Gemの定期update
## 9-3　静的解析
## 9-4　カバレッジ測定
* SimpleCov
  * テストコード実行時にカバレッジ測定結果レポートをHTMLとして出力する

## 9-5　アプリケーションパフォーマンス測定（APM）
* アプリケーションのパフォーマンスを測定するツールとしてSkylightやNew Relicなどがある
  * Skylightはシンプルにアプリケーションのパフォーマンスを測定して可視化するサービス
  * New Relicはパフォーマンス測定のほか、問題検知など含めて統合されたサービス
# 11章　複雑なドメインを表現する
## 11-1　アーキテクチャパターンから見るRails
* アプリケーションが対象とする問題領域のことをドメインと呼ぶ
* ドメインを分析して構成概念を抽出することをモデリングと呼ぶ
* 上記の結果得られた概念のことをドメインモデルと呼ぶ
* アクティブレコードはデータ取得・保存処理とドメインロジックを合わせてカプセル化したアーキテクチャパターン
  * データベースのテーブルとクラスが直接対応しているためわかりやすい
  * 単体では複雑なドメインロジックを表現しきれないという欠点がある
  * 複雑なドメインロジックとは、下記に該当するものをいう
    * ドメインに固有の「値」に関するロジック
    * 複数のオブジェクトを組み合わせて表現するロジック
## 11-2　値オブジェクト
* 属性の値に関わらず一意に識別されるオブジェクトのことをエンティティと呼ぶ
* エンティティは同一性を識別するための情報を持っており、これを識別子と呼ぶ
* Fat Modelを避けるために値オブジェクトという設計手法を用いる
* 値オブジェクトとは値が同じで同一のものと断言できない情報のことをいう
* Railsには、モデルの属性を値オブジェクトとして表現するための仕組みが用意されている
  * `composed_of :属性名, mapping: %w[モデルの属性　値オブジェクトの属性名]`
## 11-3　サービスオブジェクト
* モデルに実装すると不自然なドメインロジックを上手く表現することができる
* 導入のポイント
  * モデルに書くべきドメインロジックはサービスオブジェクトには書かないこと
    * 本来モデルが持つロジックの詳細があちこちに散らばってしまうとコードの再利用性や保守性が低下する
    * 上記を避けるために、サービスオブジェクトに実装したロジックにドメインの重要な概念が含まれていないか確認すること
  * イベントの見落としがないかを確認する
# 12章　複雑なユースケースを実現する
## 12-1　ユースケースとモデル
* RailsはURLで表されるリソースとデータベースのテーブルの一対一関係を前提として、モデルに異なる2種類のロジック（バリデーションやコールバックなど）を実装できるようにしている
* 機能要求が複雑になるにつれて上記は機能しなくなる（URLで表されるリソースとデータベースのテーブルの一対一関係が崩れるため）
## 12-2　データベースと紐づかないモデルを作る
* ユースケースのロジックを分離する
  * 複雑な機能要求を実装するレイヤーとして定義する
  * Serviceクラスよりモデルと密に連携するコントローラーやビューのメソッドの恩恵を受けれる
  * しかし、レールからは外れるためRailsから受けられる恩恵は小さくなる
* ActiveModel
  * モデルに関するモジュール群を提供するライブラリ
  * 自分で定義した素のRubyクラスにもActiveRecordと同党のインターフェースや機能を追加できる
  * データベースに紐づかないモデルのようなもの
  * ActiveModel::Attributes
    * 型を持つ属性の定義を用意にしてくれるモジュール
    * 型に合わない値を設定すると自動で型変換を行う
    * クラス内でincludeするだけで使用可能
  * ActiveModel::Callbacks
    * コールバック機能の実現を容易にしてくれるモジュール
    * `define_model_callbacks`メソッドでコールバックの対象となるメソッド名を指定する
    * 設定したコールバックを実行するには、コールバック対象のメソッド内で`run_callbacks`メソッドのブロックう必要がある
  * ActiveModel::Serialization
    * オブジェクトのシリアライズ機能の実装を容易にしてくれるモジュール
    * オブジェクトをハッシュに変換する`serializable_hash`のみ提供されている
    * ActiveModel::Serializationをincludeしただけでは使用できず、`attributes`というインスタンスメソッドが定義されていることが前提
    * `attributes`メソッドはシリアライズの必要がある属性名の文字列をキーとするハッシュを返す必要がある
  * ActiveModel::Valications
    * 属性のバリデーション機能の実装を容易にしてくれるモジュール
    * `validates_uniqueness_of`のようなデーターベースのレコードを参照するヘルパーを除いてActiveRecordと同じバリデーションヘルパーが提供されている
    * ActiveModel::Validationsをincludeするだけで使用可能
    * `before_validation`、`after_validation`コールバックは使用できない（これらを使用するにはActiveModel::Validations::Callbacksをincludeする
    * あらかじめ組み込まれているバリデーションヘルパーは`validates_absence_of`や`validates`メソッドの呼び出し時のオプションに指定して利用する
  * ActiveModel::Model
    * ActiveModelが提供するモジュールを一部にまとめたモジュール
    * ActiveModel::Modelをincludeするだけでオブジェクトをコントローラやビューのメソッドで利用できるようになる
    * また、ActiveRecordのようにオブジェクトを属性のハッシュで初期化したりバリデーションを設定して実行できるようになる
## 12-3　フォームオブジェクト
* モデルとフォームの責務を切り分けられることで、単体のモデルに依存しない場合やフォーム専用の特別な処理をモデルに書きたくない時に用いる
* `form_with`との連携に必要なインターフェースを持たせたもの
* 共通のバリデーションルールの定義
  * ActiveModel::EachValidator
    * ある1つの属性のバリデーションルールを定義するときに利用する
    * ActiveModel::EachValidatorを継承したクラスでは、`validate_each`というインスタンスメソッドにバリデーションルールを実装する
    * 属性の値がルールを満たさない場合は、オブジェクトのerror属性のメソッドを呼び出してエラーを追加する
    * 定義したバリデーションクラスは`validates`メソッドのオプションとして指定できる
  * ActiveModel::Validator
    * 複数の属性を組み合わせたバリデーションルールなど、より複雑なルールを定義するときに利用する
    * AcitveModel::Validatorを継承したクラスでは`validate`というインスタンスメソッドにバリデーションルールを実装する
    * オブジェクトがルールを満たさない場合は、ActiveModel::EachValidator同様エラーを追加する必要がある
    * エラーが特定の属性に関するものでなければ、属性名の代わりに:baseというシンボルを指定する
    * 定義したバリデーションルールは`validates_with`メソッドを呼び出すことで利用できる
## 12-4　プレゼンター
* helperの問題点
  * あるモジュールに実装したヘルパーは全てのコントローラーのビューで使用できるため、命名に注意する必要がある
* プレゼンター
  * Railsでは、あるモデルが持つ属性やロジックを利用して、表示に関するロジックを実装するオブジェクトをいう
  * Detecotrと呼ばれるデザインパターンを用いて実装されることが多いので、デコレーターとも呼ばれる
  * プレゼンターはコントローラー単位ではなくビュー単位でロジックを整理し、helperの問題を解決する
* ActiveDecorator
  * 単純なプレゼンターであれば自分でも実装できるが、保守する手間を考えるとプレゼンターを実装した何らかのgemを利用することが現実的
  * プレゼンターを定義するモジュールの名前は「#{対象のモデル名}Presenter」とする（設定を変更しない場合は「#{対象のモデル}Decorator」となる）
  * ActiveDecoratorでは、プレゼンターに実装したメソッドは基本的にはビュー内でしか利用できない

# 13章　複雑なデータ操作を実装する
## 13-1　Concern
* Concernとは
  * Railsには、app/controllers/concernsとapp/models/concernsという2つのディレクトリが用意されていて、以下の各ファイルではConcernというものを定義する
  * あるモデルるやコントローラを構成する一部の概念や機能を実装するモジュールのことを指す
  * Concernを利用することで、特定の概念や機能に関するロジックをモデル、コントローラから切り分けて実装できる
* いつ利用すべきか
  * モデルであれば、スコープと関連付けの宣言をまとめて抽出したい場合などに利用する
  * 上記の場合は値オブジェクトなど各オブジェクトでは実現できず、またオブジェクトが担う役割ではない
* 利用例
  * ConcernはActiveSupport::Concernを利用することが慣例となっていて、このモジュールをextendすることで`class_methods`やブロック渡しができる`include`メソッドが利用できるようになる
  * Concernが特定のモデルと密接に結びついていると再利用性が下がる
  * 上記を避けるために、モデルのConcernを実装する前に値オブジェクトやサービスオブジェクトとして実装できないか考える
  * コントローラも同様にモデルやフォームオブジェクトに実装できないか考える
  * それらのオブジェクトに実装する場合でない時にConcernを利用する
  * そうするとConcernはデータ操作に関するロジックの実装とモデルの関連付けの宣言を行うレイヤーとおのずとなる
* ActiveSupport::Concern
  * ActiveSupport::Concernをextendすると下記の機能を利用できるようになる
    * ブロック私ができる`include`メソッド
    * クラスメソッドの定義を容易にする`class_methods`メソッド
    * モジュール間の依存関係の解決
* ルーティングにおけるConcern
  * ルーティングにも共通の設定を抽出して再利用するための仕組みがあり、それが`concern`メソッドである
  * `concern`メソッドを利用すると複数のリソース間で共通のルーティングをConcernとして定義できる
  * 定義したConcernは、`resource(s)`メソッドのconcernsオプションまたは、`concerns`メソッドの引数にその名前のシンボルを指定することで利用できる
  * Concernのオプションを指定したい場合は、`resource(s)`メソッドのconcernsオプションに指定する方法は利用できない